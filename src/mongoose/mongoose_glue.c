// SPDX-FileCopyrightText: 2024 Cesanta Software Limited
// SPDX-License-Identifier: GPL-2.0-only or commercial
// Generated by Mongoose Wizard, https://mongoose.ws/wizard/

// Default mock implementation of the API callbacks
#include <stdint.h>
#include <stdbool.h>

#include "02_bionx_motor.h"
#include "mongoose_glue.h"
#include "10_bionxregg.h"
#include "05_can_functions.h"

// motor.h
extern int16_t assistLevel;
extern uint16_t motorSpeed;
extern uint16_t motorPower;
extern uint16_t motorTemperature;
extern uint16_t motorStatus;
extern uint32_t motorVoltage;
extern int32_t gauge;
extern int16_t rekupLevel;
extern int32_t level;
extern int16_t motorlevel; 
int16_t webassistLevel;
uint16_t temp1;
uint16_t temp2;
bool readglue = false; // Flag to indicate if settings should be read

static struct leds s_leds = {false};
void glue_get_leds(struct leds *data) {
  *data = s_leds;  // Sync with your device
}
void glue_set_leds(struct leds *data) {
  s_leds = *data; // Sync with your device
}




void glue_get_motor(struct motor *data) {
  data->power = motorPower;  // Sync with your device
  data->level = assistLevel;
  data->speed = motorSpeed;
}
void glue_set_motor(struct motor *data) {
  webassistLevel = data->level; // Sync with your device
}

void glue_get_settings(struct settings *data) {

if (readglue) {
  temp1=temp1+1;
  temp2=temp2+2;
  //readBionxRegister(BXID_MOTOR, REG_MOTOR_TORQUE_GAUGE_GAIN, &temp1);
  //readBionxRegister(BXID_MOTOR, REG_MOTOR_ASSIST_MAXSPEED, &temp2);
  data->gaugegain=(int)temp1;
  data->maxspeed=(int)temp2;
 // readglue=false;
 // data->read = false; // Reset, damit nicht nochmal gelesen wird
}
}
void glue_set_settings(struct settings *data) {
  temp2=data->maxspeed;
  writeBionxRegister(BXID_MOTOR, REG_MOTOR_TORQUE_GAUGE_GAIN, data->gaugegain);
  writeBionxRegister(BXID_MOTOR, REG_MOTOR_ASSIST_MAXSPEED, data->maxspeed);
}

static struct state s_state={"1.0.2",100,235,300,25};  // Initial version, update as needed
/*s_state.version="1.0.1";
s_state.battery = 100;  // Example values, sync with your device
s_state.power = 200;    // Example values, sync with your device
s_state.torque = 300;   // Example values, sync with your device
s_state.temperature = 25; // Example values, sync with your device
*/
void glue_get_state(struct state *data) {
  *data = s_state;  // Sync with your device
}

void *glue_ota_begin_firmware_update(char *file_name, size_t total_size) {
  bool ok = mg_ota_begin(total_size);
  MG_DEBUG(("%s size %lu, ok: %d", file_name, total_size, ok));
  return ok ? (void *) 1 : NULL;
}
bool glue_ota_end_firmware_update(void *context) {
  mg_timer_add(&g_mgr, 500, 0, (void (*)(void *)) (void *) mg_ota_end, context);
  return true;
}
bool glue_ota_write_firmware_update(void *context, void *buf, size_t len) {
  MG_DEBUG(("ctx: %p %p/%lu", context, buf, len));
  return mg_ota_write(buf, len);
}

static uint64_t s_action_timeout_reboot;  // Time when reboot ends
bool glue_check_reboot(void) {
  return s_action_timeout_reboot > mg_now(); // Return true if reboot is in progress
}
void glue_start_reboot(struct mg_str params) {
  MG_DEBUG(("Passed parameters: [%.*s]", params.len, params.buf));
  s_action_timeout_reboot = mg_now() + 1000; // Start reboot, finish after 1 second
}

void glue_get_read(struct read *data) {
data->all=readglue;  // Sync with your device
}
void glue_set_read(struct read *data) {
 readglue=data->all;  // Sync with your device
}
